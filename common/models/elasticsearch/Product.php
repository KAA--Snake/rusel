<?php
/**
 * Created by PhpStorm.
 * User: sergey
 * Date: 18.04.2017
 * Time: 17:31
 */

namespace common\models\elasticsearch;

use common\helpers\translit\Translit;
use common\modules\catalog\models\elastic\Elastic;
use common\modules\catalog\models\Section;

use Elasticsearch\Client;
use Elasticsearch\ClientBuilder;
use yii\base\Model;
use yii\data\Pagination;
use yii\elasticsearch\Exception;
use yii\redis\Cache;

class Product extends Model
{

    const productData = [
        'index' => 'product',
        'type' => 'product_type',
    ];

    //это будет добавляться к запросам, в которых нужен скролл
    //public static $scroll;


    public function init()
    {
        parent::init(); // TODO: Change the autogenerated stub

        /** Сохраним для использования, если пришел из сессии scrollId */
        /*$sessionScroll = \Yii::$app->session->get('getProductsBySectionId');
        if(isset($sessionScroll) && !empty($sessionScroll)){

            static::$scroll['scroll_id'] = $sessionScroll;

            //очистим скролл для нового
            \Yii::$app->session->remove('getProductsBySectionId');
        }*/
    }



    public function attributes(){
        return [
            //'_id',
            'id',
            'section_id',
            'url',
            'status',
            'sort',
            'name',
            'code',
            'artikul',
            'ed_izmerenia',
            'product_logic',
            'properties',
            'other_properties',
            'prices',
            'quantity',
            'marketing',
        ];
    }


    public function rules(){
        return [
            [['id', 'name', 'code', 'artikul', 'status'], 'required'],
            [['id', 'section_id', 'status'], 'integer'],
            [['id'], 'unique'],
            [['sort'], 'default', 'value' => 100],
            [['url'], 'string'],
        ];
    }



    public function clearAllProducts(){

        $params = [
            "query" => [
                'index' => 'product',
                "match_all" => new \stdClass()
            ]
        ];
        $ch = curl_init( 'http://elasticsearch:9200/product' );
        # Setup request to send json via POST.
        /*$payload = json_encode( array(
            "login"=> 'elastic',
            "password"=> 'changeme',
        ) );*/
        //curl_setopt( $ch, CURLOPT_POSTFIELDS, $payload );
        curl_setopt( $ch, CURLOPT_HTTPHEADER, array('Content-Type:application/json'));
        curl_setopt( $ch, CURLOPT_RETURNTRANSFER, true );
        //curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'PUT');
        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'DELETE');
        curl_setopt($ch, CURLOPT_USERPWD, Elastic::$user . ":" . Elastic::$pass);


        $result = curl_exec($ch);
        curl_close($ch);

        //var_dump($result);
    }


    /**
     * первоначаьлный маппинг
     */
    public function mapIndex(){


        $client = ClientBuilder::create()->build();
        $params = [
            'index' => 'product',
            'body' => [

                'settings' => [
                    'number_of_shards' => 5,
                    'number_of_replicas' => 2,

                    "analysis" => [
                        "analyzer"   => [
                            "analyzer_keyword" => [
                                "tokenizer" => "standard",
                                "filter"    => ["lowercase", "asciifolding"]
                            ],
                            ///
                            'removed_spec_symbols_analizer' => [
                                'type' => 'custom',

                                'char_filter' => [
                                    'replace_symbols',
                                ],

                                'filter' => [
                                    'lowercase',
                                ],

                                'tokenizer' => 'words_by_whitespace',
                            ],

                            'removed_chars_analizer' => [
                                'type' => 'custom',

                                'char_filter' => [
                                    'replace_symbols',
                                ],

                                'filter' => [
                                    'lowercase',
                                    //'asciifolding'
                                ],

                                'tokenizer' => 'punctuation',
                            ],

                            //замена символов на кириллицу в латиницу
                            'cyrillic_to_latinyc_analizer' => [
                                'type' => 'custom',

                                'char_filter' => [
                                    'replace_symbols',
                                    'cyrillic_to_latinyc'
                                ],

                                'filter' => [
                                    'lowercase',
                                    //'asciifolding'
                                ],

                                'tokenizer' => 'words_by_whitespace',
                            ],

                            //замена символов на латиницу в кириллицу
                            'latinyc_to_cyrillic_analizer' => [
                                'type' => 'custom',

                                'char_filter' => [
                                    'replace_symbols',
                                    'latinyc_to_cyrillic'
                                ],

                                'filter' => [
                                    'lowercase',
                                    //'asciifolding'
                                ],

                                'tokenizer' => 'words_by_whitespace',
                            ]
                        ],

                        //char filters to connect to analyzers
                        'char_filter' => [

                            //не учитывать всякие запятые и прочие символы
                            'replace_symbols' => [
                                'type' => 'pattern_replace',
                                'pattern' => '[\.\,\\\/\:\_\-]',
                                'replacement' => ''
                            ],

                            //замена символов на кириллицу в латиницу
                            'cyrillic_to_latinyc' => [
                                'type' => 'mapping',
                                'mappings' => [
                                    //cyr -> lat block
                                    'е => e',
                                    'т => t',
                                    'о => o',//Оооо (не ноль, а именно ооо)
                                    'р => p',
                                    'а => a',
                                    'н => h',
                                    'к => k',
                                    'х => x',
                                    'с => c',
                                    'в => b',
                                    'м => m',
                                ]
                            ],

                            //замена символов на латиницу в кириллицу
                            'latinyc_to_cyrillic' => [
                                'type' => 'mapping',
                                'mappings' => [
                                    //lat -> cyr block
                                    'e => е',
                                    't => т',
                                    'o => о',//Оооо (не ноль, а именно ооо)
                                    'p => р',
                                    'a => а',
                                    'h => н',
                                    'k => к',
                                    'x => х',
                                    'c => с',
                                    'b => в',
                                    'm => м',
                                ]
                            ],

                        ],


                        "normalizer" => [
                            "lowerasciinormalizer" => [
                                "type"   => "custom",
                                "filter" => ["lowercase", "asciifolding"]
                            ]
                        ],

                        "tokenizer" => [
                            "punctuation" => [
                                "type" => "pattern",
                                "pattern" => "[\.\,\\\/\:\_\-]"
                            ],

                            "words_by_whitespace" => [
                                "type" => "pattern",
                                "pattern" => " "
                            ],

                        ]

                    ]



                ],
                'mappings' => [
                    'product_type' => [
                        '_source' => [
                            'enabled' => true
                        ],
                        'properties' => [
                            'url' => [
                                'type' => 'keyword',
                                //'analyzer' => 'standard'
                            ],
                            'proizv_id' => [
                                'type' => 'integer',
                                //'analyzer' => 'standard'
                            ],
                            'section_id' => [
                                'type' => 'integer'
                            ],
                            'id' => [
                                'type' => 'integer'
                            ],
                            'sort' => [
                                'type' => 'integer'
                            ],
                            /*'artikul' => [
	                            'type' => 'text',
	                            'fields' => [
                                    'raw' => [
                                        'type' => 'keyword'
                                    ]
                                ]
                            ],*/

                            'name' => [
                                'type' => 'text',

                                'fields' => [
                                    'raw_text'=> [
                                        'type' => 'text',
                                        'analyzer' => 'default'
                                    ],
                                    'for_filter' => [
                                        'type' => 'text',
                                        'analyzer' => 'removed_chars_analizer'
                                    ],
                                    'cyrillic_to_latinyc' => [
                                        'type' => 'text',
                                        'analyzer' => 'cyrillic_to_latinyc_analizer'
                                    ],
                                    'latinyc_to_cyrillic' => [
                                        'type' => 'text',
                                        'analyzer' => 'latinyc_to_cyrillic_analizer'
                                    ],
                                    'test_field' => [
                                        'type' => 'text',
                                        'analyzer' => 'removed_spec_symbols_analizer'
                                    ],
                                ]

                            ],

                            'artikul' => [
                                'type' => 'keyword',
                                //'search_analyzer' => 'defaul',
                                //'search_analyzer' => 'analyzer_keyword',
                                'normalizer' => 'lowerasciinormalizer',
                                //мульти поле, для сортировки по нему
                                'fields' => [
                                    'raw_text'=> [
                                        'type' => 'text',
                                        'analyzer' => 'default'
                                    ],
                                    'for_filter' => [
                                        'type' => 'text',
                                        'analyzer' => 'removed_chars_analizer'
                                    ],
                                    'cyrillic_to_latinyc' => [
                                        'type' => 'text',
                                        'analyzer' => 'cyrillic_to_latinyc_analizer'
                                    ],
                                    'latinyc_to_cyrillic' => [
                                        'type' => 'text',
                                        'analyzer' => 'latinyc_to_cyrillic_analizer'
                                    ],
                                    'test_field' => [
                                        'type' => 'text',
                                        'analyzer' => 'removed_spec_symbols_analizer'
                                    ],

                                ]
                            ],

                            'properties.proizvoditel' => [
                                'type' => 'keyword'
                            ],
                            'properties.prinadlejnosti' => [
                                'type' => 'keyword'
                            ],

                            'properties.detail_text' => [
                                'type' => 'text',
                                //мульти поле, для сортировки по нему
                                'fields' => [
                                    'raw_text'=> [
                                        'type' => 'text',
                                        'analyzer' => 'default'
                                    ],
                                    'for_filter' => [
                                        'type' => 'text',
                                        'analyzer' => 'removed_chars_analizer'
                                    ],
                                    'cyrillic_to_latinyc' => [
                                        'type' => 'text',
                                        'analyzer' => 'cyrillic_to_latinyc_analizer'
                                    ],
                                    'latinyc_to_cyrillic' => [
                                        'type' => 'text',
                                        'analyzer' => 'latinyc_to_cyrillic_analizer'
                                    ],
                                    'test_field' => [
                                        'type' => 'text',
                                        'analyzer' => 'removed_spec_symbols_analizer'
                                    ],
                                ]
                            ],

                            'prices' => [
                                'type' => 'nested',

	                            "properties" => [

		                            "total" => [ "type" => "integer" ],
		                            "stores" => [ "type" => "integer" ],
		                            "storage" => [
		                            	"type" => "nested",

			                            "properties" => [
				                            "id" => [ "type" => "keyword" ],
				                            "quantity" => [ "type" => "nested" ],
				                            "marketing" => [ "type" => "nested" ],
				                            "prices" => [ "type" => "nested"],
			                            ]


		                            ],
							    ]
                            ],

                            'quantity' => [
                                'type' => 'nested'
                            ],


                            'other_properties' => [
                                'type' => 'nested',

                                "properties" => [

                                    "property" => [
                                        "type" => "nested" ,

                                        "properties" => [
                                            "id" => [ "type" => "integer" ],
                                            "sort" => [ "type" => "integer" ],
                                            "name" => [ "type" => "keyword" ],
                                            "value" => [ "type" => "keyword" ],
                                        ]
                                    ],

                                ]


                            ]


                        ],






                            /*'other_properties' => [
                                "type" => "nested",
                            ],*/

                            /*'other_properties.property' => [

                                "type" => "nested",
                                "properties" => [
                                    "id" => [ "type" => "integer" ],
                                    "sort" => [ "type" => "integer" ],
                                    "name" => [ "type" => "keyword" ],
                                    "value" => [ "type" => "keyword" ],
                                ]

                            ],*/

                            /*'other_properties.property.id' => [
                                'type' => 'integer'
                            ],
                            'other_properties.property.sort' => [
                                'type' => 'integer'
                            ],
                            'other_properties.property.name' => [
                                'type' => 'keyword'
                            ],
                            'other_properties.property.value' => [
                                'type' => 'keyword'
                            ],*/


                        ]
                    ]
                ]

        ];

        // Create the index with mappings and settings now
        $response = Elastic::getElasticClient()->indices()->create($params);

        // Update the index mapping
       // static::getElasticClient()->indices()->create($params);

    }



    /**
     * Генерирует параметры для bulk загрузки, используется для сохранения булки для
     * отправки ее через раббит на сохранение в бд
     *
     * @param $product
     * @return array
     */
    public function getParamsForBulkLoad(&$product){

        /**
         * если не задан код, берем его транслитом из артикула
         */
        if(empty($product['code']) || $product['code'] == ''){

            //если артикул есть
            if(!empty($product['artikul']) && $product['artikul'] != ''){
                $product['code'] = $product['artikul'];
            }else{
                //если артикула нет, делаем код из имени
                $product['code'] = $product['name'];
            }
            $product['code'] = Translit::t($product['code']);
        }else{
            $product['code'] = str_ireplace(['/','\\'], '', $product['code']);
        }

        /** сгенерим урл из урла раздела/урла товара */
        $product['url'] = $this->__generateUrl($product['code'], $product['section_id']);

		//\Yii::$app->pr->print_r2($product);


        /*$params = [
            'id' => $product['id'],
            //'routing' => 'company_xyz',
            //'timestamp' => strtotime("-1d"),
            'body' => $product
        ];*/


        $params['for_index'] = array(
            'index' => array(
                '_index' => 'product',
                '_type' => 'product_type',
                '_id' => $product['id'],
            )
        );

        $params['for_body'] = $product;

        /*foreach($comments as $comment) {
            $params['body'][] = [
                'index' => [
                    '_parent' => $product['id']
                ]
            ];

            $params['body'][] = (array) $comment;
        }*/

        //добавляем базовую инфу (название индекса и тп)
        //$params = self::productData+$params;

        return $params;
    }


	/**
	 * Генерирует параметры для bulk загрузки ОСТАТКОВ, используется для сохранения булки для
	 * отправки ее через раббит на сохранение в бд
	 *
	 * Отличия от getParamsForBulkLoad в том, что исопльзуется update вместо index
	 *
	 * @param $product
	 * @return array
	 */
	public function getParamsForBulkLoadRemains(&$product){
		//\Yii::$app->pr->print_r2($product);
		//die();
		$params['for_index'] = array(
			'update' => array(
				'_index' => 'product',
				'_type' => 'product_type',
				'_id' => $product['id'],

			)
		);

		//удаляем ненужный ИД (он же пойдет в блок prices, а там он не нужен)
		unset($product['id']);

		$params['for_body'] = [
			'doc' => [
				'prices' => $product
			],
			//'script' => 'ctx._source.remove("prices")',
			//'doc_as_upsert' => true,
			'detect_noop' => false
		];

		/*foreach($comments as $comment) {
			$params['body'][] = [
				'index' => [
					'_parent' => $product['id']
				]
			];

			$params['body'][] = (array) $comment;
		}*/

		//добавляем базовую инфу (название индекса и тп)
		//$params = self::productData+$params;

		return $params;
	}


	/**
	 * Удаляет полностью блок prices.
	 * Нужен для того, чобы не было наслоений старых данных и новых.
	 * Вместо него можно использовать пустые блоки.
	 *
	 * @return mixed
	 */
	public function clearBlockForUpdate(&$product){
		//\Yii::$app->pr->print_r2($product);
		$params['for_index'] = array(
			'update' => array(
				'_index' => 'product',
				'_type' => 'product_type',
				'_id' => $product['id'],
			)
		);

		$params['for_body'] = [
			"script" => 'ctx._source.remove("prices");',
			//'script' => 'ctx._source.remove("prices")',
			//'doc_as_upsert' => true,
			'detect_noop' => false
		];

		return $params;
	}




    public function addProduct($productData){

        $params = [
            'id' => $productData['id'],
            //'routing' => 'company_xyz',
            //'timestamp' => strtotime("-1d"),
            'body' => $productData
        ];

        //добавляем базовую инфу (название индекса и тп)
        $params = self::productData+$params;

        try{
            $response = Elastic::getElasticClient()->index($params);
            return true;

        }catch(\Exception $e){

            $message = json_decode($e->getMessage());

            $mesObj = [
                'ID' => $params['id'],
                'ERR_DESC' => $message->error->reason
            ];

            $_SESSION['ERRORS'][] = $mesObj;

            \Yii::error($mesObj, 'rabbit_import_error');

            //file_put_contents('/webapp/import_error.log', print_r($mesObj, true), FILE_APPEND);

            //\Yii::$app->pr->print_r2($params);
            return false;
        }

        return false;
        //$response = Elastic::getElasticClient()->update($params);

    }

    /**
     * Прикручивает к выборке связанные товары
     *
     * @deprecated дальнейшее использование только в статическом методе, т.к. это хелпер.
     *
     * @param $productsList
     * @return bool
     */
    public function setAccessoriedProducts(&$productsList){

        //оставлено для обратной совместимости
        return static::setAccessoriedProds($productsList);


       // \Yii::$app->pr->print_r2($productsList);

        /*foreach($productsList as &$oneProduct){

            //\Yii::$app->pr->print_r2($oneProduct);

            if(!empty($oneProduct['_source']['properties']['prinadlejnosti'])){

                $ids = explode(';', $oneProduct['_source']['properties']['prinadlejnosti']);
                //\Yii::$app->pr->print_r2($ids);
                $params = [
                    'body' => [
                        //'from' => 0,
                        //'size' => 3,
                        'query' => [
                            'ids' => [
                                'values' => $ids
                            ]
                        ]
                    ]
                ];

                $params = static::productData + $params;
                $response = Elastic::getElasticClient()->search($params);

                //\Yii::$app->pr->print_r2($params);
                //\Yii::$app->pr->print_r2($response);
                $oneProduct['_source']['accessories'] = $response['hits']['hits'];

            }
        }

        return true;*/

    }

    /**
     * Прикручивает к выборке связанные товары
     *
     *
     * @param $productsList
     * @return bool
     */
    public static function setAccessoriedProds(&$productsList){
        // \Yii::$app->pr->print_r2($productsList);
        foreach($productsList as &$oneProduct){

            //\Yii::$app->pr->print_r2($oneProduct);

            if(!empty($oneProduct['_source']['properties']['prinadlejnosti'])){

                $ids = explode(';', $oneProduct['_source']['properties']['prinadlejnosti']);
                //\Yii::$app->pr->print_r2($ids);
                $params = [
                    'body' => [
                        //'from' => 0,
                        //'size' => 3,
                        'query' => [
                            'ids' => [
                                'values' => $ids
                            ]
                        ]
                    ]
                ];

                $params = static::productData + $params;
                $response = Elastic::getElasticClient()->search($params);

                /*\Yii::$app->pr->print_r2($params);
                \Yii::$app->pr->print_r2($response);*/
                $oneProduct['_source']['accessories'] = $response['hits']['hits'];

            }
        }

        return true;
    }


    /**
     * Получает список товаров по ИД раздела
     *
     * @param $sectionId
     * @return array
     * @internal param $productId
     */
    public function getProductsBySectionId($sectionId){

        $maxSizeCnt = \Yii::$app->getModule('catalog')->params['max_products_cnt'];
        $from = 0;
        $page = 1; //изначально первая страница

        $pagination = [];


        $perPagePicked = \Yii::$app->request->get('perPage');

        if(isset($perPagePicked) && $perPagePicked > 0){
            $maxSizeCnt = $perPagePicked;
        }

        $pagination['max_elements_cnt'] = $maxSizeCnt;
        $pagination['current_page'] = $page;
        //echo $pagination->offset;
        //\Yii::$app->pr->print_r2($pagination);
        //die();
        $pagePicked = \Yii::$app->request->get('page');

        $needPage = $pagePicked -1;

        if(isset($pagePicked) && $pagePicked > 0){

            //echo 'page = ' . $page . '<br />';
            //echo '$maxSizeCnt = ' . $maxSizeCnt . '<br />';
            $from = $needPage * $maxSizeCnt;

            //\Yii::$app->pr->print_r2($from);

            $pagination['current_page'] = $pagePicked;
        }

        $params = [
            'body' => [
                'from' => $from,
                'size' => $maxSizeCnt,
                'sort' => [
                    'artikul' => ['order' => 'asc']
                ],
                'query' => [
                    'term' => [
                        'section_id' => $sectionId
                    ]
                ]
            ]
        ];

        $params = static::productData + $params;

        $response = Elastic::getElasticClient()->search($params);

        $returnData = [];

        if(!empty($response['hits']['hits'][0]['_source']) && isset($response['hits']['hits'][0]['_source'])){

            //заполняем totalCnt
            $pagination['totalCount'] = $response['hits']['total'];

            /** заполним выборку аксессуарами */
            $this->setAccessoriedProducts($response['hits']['hits']);
            $returnData['products'] = $response['hits']['hits'];
            //\Yii::$app->pr->print_r2($returnData['products']);

            $returnData['paginator'] = $pagination;
            $returnData['totalProductsFound'] =  $response['hits']['total'];

            return $returnData;
        }

        //die();
        return false;

    }





    /**
     * Отдает список товаров по их Артикулам
     *
     * @deprecated в дальнейшем не использовать. Поиск будет идти в ProductSearch
     *
     * @param array $articles
     * @return array
     * @internal param $ids
     */
    public function getProductsByArticles($articles=[]){

        if(count($articles) <= 0){
            return [];
        }

        /**
         *  здесь адова нагрузка
         */
        $productsFound = [];
        foreach($articles as $oneArtikul){

            $params = [
                'body' => [
                    //'from' => $from,
                    'size' => 100,
                    'sort' => [
                        'artikul' => 'asc'
                    ],
                    'query' => [
                        'prefix' => [
                            'artikul' => [
                                'value' => $oneArtikul,
                                //'boost' => 2.0
                            ]
                        ]
                    ]
                ]
            ];


            $params = static::productData + $params;

            //\Yii::$app->pr->print_r2(json_encode($params));

            $response = Elastic::getElasticClient()->search($params)['hits']['hits'];

            //\Yii::$app->pr->print_r2($response);

            //добавляем аксессуары к продуктам
            $this->setAccessoriedProducts($response);

            //\Yii::$app->pr->print_r2($response);

            $productsFound[] = $response;

            unset($response);

        }

        return $productsFound;
    }






    /**
     * Сохранение из парсера
     * @param $product
     * @internal param $group
     */
    public function saveProduct(&$product){

        /**
         * если не задан код, берем его транслитом из артикула
         */
        if(empty($product['code']) || $product['code'] == ''){

            //если артикул есть
            if(!empty($product['artikul']) && $product['artikul'] != ''){
                $product['code'] = $product['artikul'];
            }else{
                //если артикула нет, делаем код из имени
                $product['code'] = $product['name'];
            }
            $product['code'] = Translit::t($product['code']);
        }else{
            $product['code'] = str_ireplace(['/','\\'], '', $product['code']);
        }

        /** сгенерим урл из урла раздела/урла товара */
        $product['url'] = $this->__generateUrl($product['code'], $product['section_id']);

        return $this->addProduct($product);
    }


    /**
     * Генерирует УРЛы для товаров и пишет их в соотв поле таблицы...надо ли ?
     *
     * @return bool
     */
    private function __generateUrl($productCode, $sectionUniqueId){
        $section = false; //первоначально раздела для товара нет

        /*\Yii::$app->redis->set('mykey', 'some value');
        echo \Yii::$app->redis->get('mykey');*/

        /** @var Cache $cache */
        $cache = \Yii::$app->cache;

        if($sectionUniqueId > 0 && !empty($sectionUniqueId)){

            $cache = \Yii::$app->cache;

	        //\Yii::$app->pr->print_r2($productCode);

            if (!$section = $cache->get('getSection'.$sectionUniqueId)){

	            //\Yii::$app->pr->print_r2($section);
                //Получаем данные из таблицы (модель TagPost)
                $section = Section::find()->andWhere(['unique_id' => $sectionUniqueId])->asArray()->one();

                //Устанавливаем зависимость кеша от кол-ва записей в таблице
                //$dependency = new \yii\caching\DbDependency(['sql' => 'SELECT COUNT(*) FROM {{%tag_post}}']);
                $cache->set('getSection'.$sectionUniqueId, $section, 1000);
            }

        }else{
            //@TODO нет раздела для товара, значит сбрасываем его в корень кталога. Подумать как это реализовать!
            return $productCode;
        }

        /*echo '$section->url = ' . $section->url . '<br />';
        echo '$productCode = ' . $productCode . '<br />';
        echo 'URL = '.$section->url.$productCode.'/' . '<br />';*/

        if($section){
            //echo 'Уникальный ИД: '.$section->unique_id . '<br />';

            //выпиливаем слеши для сохранения в базе
            $url = str_replace('/', '|', $section['url'].$productCode);
            //$url = md5($url);

	        //\Yii::$app->pr->print_r2($url);
            //return 'electric_productsaksessuary-dlya-klemmmarkirovka2035-0';
            return $url;
        }else{
            //@TODO не найден такой раздела в каталоге для товара, сбрасываем товар в корень каталога
            return $productCode;
        }

        //если раздела не существует, то хотя бы генерим урл из кода
        return $productCode.'/';
    }




}